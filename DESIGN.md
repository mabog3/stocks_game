note: all dependencies are listed in requirements.txt

Some of the core features of this project - namely, the buy/sell capability, as well as the ability to see a stock quote and the ability to view the user's stock portfolio are expansions of my work for PSET 9: Finance. However, in this project the SQLite database so that every stock (table 'portfolio') was associated with not just a quantity and an owner, but also a game. These 'games', indexed by their primary key gamenumber, themselves contained the information about the game, including the players and the duration. In this way, it was possible to distinguish between operations performed on a particular game, so that when a player is playing 3 games at a given time, they can (and, in fact, must) choose to purchase AAPL for just one of those games without affecting the others. By storing the available cash as a stock object in the portfolio table, it was likewise possible to compare/update a user's cash balance for each game seperately, as a purchase for game with gamenumber 3 would call a subtraction of cash from a row in portfolio where the (pseudo-)stock symbol is 'Cash' (as distinct from the all-caps CASH, which is a stock ticker) and the gamenumber is also 3. All transactions/items for the 'personal portfolio,' which is essentiqally the same mechanism as in Finance wherein a player can simulate stock trading just for themselves, has a gamenumber of 0, and quantities/items are only distinguished by user ids, which are unique. 

The duration-based game system called for checking whether any of the user's game durations had ended, and if so, to calculate the winner based on the highest portfolio value. This is all done by the timeRemaining() function in application.py which updates the game table to set the particular game's 'finished' value to 1, to which the application responds by not considering that game active - i.e. stocks can't be bought/sold for it, and it appears in 'past games' on the games page. timeRemaining() uses the python datetime library to subtract the current time/date and the game's start date (which is stored in the database upon initialization) and compare it to the game's duration - naturally, if the former is larger the game is over. 

Similarly, the games were also given an 'initialized' column, default 0, in the database, in order to enable an invite system instead of any player being able to start a game with any other player without the other player's agreement. Then, the initialized=0 games are simply not options for buying/selling stock, viewing history, etc. and only appear on the 'recieving' player's invites screen, where by accepting the invite initialized is set to 1 and all of those features are enabled. In terms of who is the 'recieving player,' the fact that when a new game is started, the current logged-in user (i.e. the one starting the game) is always stored as player 1, makes it easy to identify the 'recipient' (player 2) for that purpose; however, it unfortunately made the problem of potentially adding games with more than 2 players somewhat intractable. 

Lastly, in terms of minor features, some JS and HTML validation of things like the presence of needed form inputs / formats/ sizes were added to give as much feedback as possible about input to the user before they press submit and have to wait for the back-end processes. Also, the quote feature was improved by the historicalPlot() function in helpers.py, which generates a candlestick graph of the searched stock's performance. Also, a simple search feature for usernames was implemented by calling SQL LIKE % x % query on the users database where x is the search input, to 'cast a wide net' of the search results. Also, a profile feature that gives users to update the user table in the database and change their username, password, and description was also added, with these functions operating very similarly to the register function.